<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:Vue 2</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h3 id="webpack">webpack</h3>
<p>从网络上下载 模块</p>
<pre><code class="lang-vue">// 打开终端 输入 npm install jquery -S
从网络上下载 jquery 文件
-S 是 --save 的简写
</code></pre>
<h4 id="-webpack">安装 webpack</h4>
<p>npm install webpac -D</p>
<h5 id="-webpack">配置 webpack</h5>
<pre><code class="lang-vue">module.exports = {

mode: &quot;development&quot;   //mode 用来指定 构建模式  可选的有 development 和 production

development 在开发阶段 使用  打包速度快 但体积大

production 在上线阶段使用 打包速度慢 但体积小

}
</code></pre>
<h5 id="-">自定义打包入口与出口</h5>
<pre><code class="lang-vue">const pash = require(&quot;path&quot;)

module.exports = {

entry.pash.join(__dirname,&quot;./src/index.js&quot;) 打包文件路径

output: {

__dirname 表示文件的根目录

 path:path.join(__dirname, &quot;/dist&quot;)  输出文件路径

folename: &quot;bundle.js&quot;  // 输出文件名称

}

}
</code></pre>
<h5 id="webpack-">webpack  插件</h5>
<ol>
<li><p>webpack-dev-sarver  // 每次修改源代码 webpack 就会自动进行项目的打包和构建</p>
<p>插件的安装 ：npm install <a href="mailto:webpack-dev-server@3.11.2">webpack-dev-server@3.11.2</a> -D</p>
</li>
<li><p>html-webpack-plugin </p>
<p>webpack 中的 HTML 插件 </p>
<p>可以通过此插件制定 html 页面的内容</p>
<p>webpack 只能打包 以 js 结尾的文件</p>
<p>打包其他的文件会报错</p>
</li>
</ol>
<h5 id="-css-loadle-">安装 css-loadle 插件</h5>
<p>npm i style-loader css-loader -D</p>
<p>webpack 识别 css 文件会报错 这时就需要 css-loader 插件</p>
<h5 id="-less-loader-">安装 less-loader 插件</h5>
<p>npm i less-loader less -D</p>
<pre><code class="lang-web-idl">module: {
        rules:[
            // 文件后缀名的匹配规则 
            {test: /\.css$/,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]},
            // {test: /\.less$/,use:[&#39;style-loader&#39;,]}
        ]
    }
</code></pre>
<h5 id="-url-loader-">安装 url-loader 模块</h5>
<p>npm i url-loader file-loader -D</p>
<pre><code class="lang-web-idl">// url-loader 的配置文件
module: {
        rules:[
            {test: /\.jpg|gif|png$/,use:[&#39;url-loader?limit=22229&#39;]}  //limit= 文件的大小 大于这个数不会转成 base64格式 
        ]
    }
</code></pre>
<h5 id="-babel-loader-">安装 babel-loader 模块</h5>
<p>对应webpack 无法处理的 js 高级语法 需要使用这个模块</p>
<pre><code class="lang-web-idl">// 下载命令
// npm i babel-loader @babel/core @babel/plugin-proposal-decorators -D
// 配置文件
// 在文件的根目录创建一个 babel.config.js 文件
module.exports = {
    plugins: [[&quot;@babel/plugin-proposal-decorators&quot;,{legacy:true}]]
}
</code></pre>
<p>将 内存的 文件 添加到物理磁盘上面</p>
<pre><code class="lang-web-idl"> // 将以下代码添加到 package.json 文件中
 &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack serve&quot;, // 开发环境下运行的 命令
    &quot;build&quot;: &quot;webpack --mode production&quot;  // 项目发布时，运行 build 命令
  },
</code></pre>
<h5 id="-js-js-">将打包好的 js 文件放到 js 文件夹中</h5>
<pre><code class="lang-web-idl">output: {
        path: path.join(__dirname,&#39;dist&#39;),
        // 生成的文件名
        filename: &quot;js/bundle.js&quot;
    },
</code></pre>
<h5 id="-dist-image-">将打包好的 图片放到 打包好的 dist 文件下的 image 文件中</h5>
<pre><code class="lang-web-idl">{test: /\.jpg|gif|png$/,use:{
                loader: &#39;url-loader&#39;,
                options:{
                    limit: 22228,
                    // 声明把打包生成的图片文件，存储到 dist 文件目录下 image 文件夹中
                    outputPath: &#39;image&#39;
                }
            }},
 // 第二种写法 (提倡第二种)
 {test: /\.jpg|gif|png$/,use:[&quot;url-loader?limit=478&amp;outputPath=image&quot;]}
</code></pre>
<h5 id="-dist-">每次打包先删除 旧版本的 dist 文件</h5>
<p>这样可以省略我们需要手动删除</p>
<pre><code class="lang-web-idl">//在webpack 配置文件中的头部 添加 
const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;);
//在 plugins 数组中添加 new CleanWebpackPlugin()
plugins: [new CleanWebpackPlugin()],
</code></pre>
<h5 id="source-map">Source Map</h5>
<p>Source Map 就是一个信息文件 里面存储着位置信息 有了它 出错的时候直接显示源代码，而不是转换后的代码，方便后期的调试</p>
<pre><code>devtool: &#39;eval-source-map&#39;,
</code></pre><h5 id="-">@ 的原理和好处</h5>
<p>导入文件 时 @ 符号表示从 src 的文件下从外往里查找  ../ 则是从里往外查找 @/</p>
<pre><code>//webpack 不能直接识别 @ 需要配置
resolve 和 module 平级
resolve:{
        alias:{
            &quot;@&quot;:path.join(__dirname,&#39;./src/&#39;)
        }
    }

</code></pre><h5 id="-webpack-vue-">删除webpack 里面 vue的组件</h5>
<pre><code class="lang-bash">npm uni i vue -S
</code></pre>
<h5 id="-vue">安装 vue</h5>
<pre><code>npm i vue@要安装的版本 -S
</code></pre><h3 id="vue-2">Vue 2</h3>
<h4 id="-vue">什么是 Vue</h4>
<ol>
<li><p>构建用户界面</p>
<p>用 Vue 往页面填充数据</p>
</li>
<li><p>框架</p>
<p>框架是一种现成的解决方案 程序员只能遵守框架的规范 去编写自己的业务代码</p>
</li>
</ol>
<h4 id="vue-">Vue 的主要特性</h4>
<ol>
<li>数据驱动视图</li>
<li>双向数据绑定</li>
</ol>
<h5 id="-1-">（1）数据驱动视图</h5>
<ol>
<li><p>数据的变化会驱动视图的自动更新</p>
<p>好处：程序员只管操作视图 页面结构会自动渲染</p>
</li>
</ol>
<h5 id="-2-">（2）双向数据绑定</h5>
<ol>
<li><p>在网页中 from 表单负责采集数据 Ajax 负责提交数据</p>
<p>js 数据的变化，会被自动渲染到页面上</p>
<p>页面上表单采集的数据发生变化时，会被 Vue 自动获取到 并更新到 js 数据中</p>
</li>
</ol>
<h4 id="vue-">Vue 的实现原理</h4>
<p>mvvm : 指的时 model view viewModel</p>
<ol>
<li>model 表示当前页面所需要的 数据源</li>
<li>view 表示 当前页面所渲染的 DOM 结构</li>
<li>view Model 表示 Vue 的实例 它是 MVVM 的核心</li>
</ol>
<h4 id="vue-">Vue的六大指令</h4>
<ul>
<li>内容渲染指令</li>
<li>数据绑定指令</li>
<li>事件绑定指令</li>
<li>双向数据绑定</li>
<li>条件渲染指令</li>
<li>列表渲染指令</li>
</ul>
<h5 id="-1-">（1）内容指令</h5>
<p>v-text </p>
<p>标签会覆盖元素内原有的内容</p>
<p>{{ }} 插值表达式 </p>
<p>在实际开发中用的最多</p>
<p>v-html </p>
<p>可以将标签添加到页面中 并且标签内可以添加样式</p>
<h5 id="-2-">（2）属性绑定指令</h5>
<p>注意：插值表达式只能用在内容中 不能用在属性中</p>
<p>v-bind: 属性元素 也可以简写成 ：</p>
<pre><code class="lang-vue">// 设置图片路径
&lt;img v-bind:src=&quot;photo&quot; alt=&quot;&quot;&gt;
&lt;script&gt;
        const vm = new Vue({
            el: &#39;.app&#39;,
            data: {
                tips: &#39;输入用户名&#39;,
                photo: &#39;https://i1.hdslb.com/bfs/archive/19e5b1dab155924a3cff2c832cbfd802eb6a14de.jpg@672w_378h_1c.webp&#39;
            }
        })
    &lt;/script&gt;
</code></pre>
<pre><code class="lang-vue">// 需要进行字符串的拼接 需要用上单引号
&lt;div :title=&quot;&#39;box&#39; +index&quot;&gt;这是一个div&lt;/div&gt;
</code></pre>
<h5 id="-3-">（3）事件绑定指令</h5>
<p>v-on:绑定事件的函数=“”</p>
<pre><code class="lang-vue">&lt;div class=&quot;app&quot;&gt;
        &lt;p&gt;cont 的值是：{{cont}}&lt;/p&gt;
        &lt;button @click=&quot;add(3)&quot;&gt;+N&lt;/button&gt;
    &lt;/div&gt;
&lt;script&gt;
        const vm = new Vue({
            el: &#39;.app&#39;,
            data:{
                cont: 1,
            },
            // 事件创建 函数
            methods: {
                add(n){
                    this.cont += n
                },
            }
        })
    &lt;/script&gt;
</code></pre>
<h5 id="-">事件修饰符</h5>
<pre><code class="lang-vue">&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;跳转到百度首页&lt;/a&gt; //阻止链接跳转
methods:{
                btn(e){
                    console.log(&#39;a被点击了&#39;)
                    console.log(e)
                    // e.preventDefault()
                }
            }
</code></pre>
<table>
<thead>
<tr>
<th>事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.prevent</td>
<td>阻止事件的默认行为</td>
</tr>
<tr>
<td>.stop</td>
<td>阻止事件的冒泡</td>
</tr>
<tr>
<td>.capture</td>
<td>以捕获模式触发当前事件的处理函数</td>
</tr>
<tr>
<td>.once</td>
<td>绑定的事件只触发一次</td>
</tr>
<tr>
<td>.self</td>
<td>只有在 event.target 是当前元素自身时触发的事件处理函数</td>
</tr>
</tbody>
</table>
<h5 id="-">按键修饰符</h5>
<pre><code class="lang-vue">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; @keyup.esc=&quot;key&quot; @keyup.enter=&quot;getinput&quot;&gt;
 &lt;script&gt;
        const vm = new Vue({
            el: &#39;.box&#39;,
            data:{},
            methods:{
                //点击 esc 按键 清空 输入框的值
                key(e){
                    e.target.value = &#39;&#39;
                },
                // 点击回车按键 获取 输入框的值
                getinput(e){
                    console.log(e.target.value)
                }
            }
        })
    &lt;/script&gt;
</code></pre>
<h4 id="-">双向数据绑定指令</h4>
<h5 id="-">主要功能</h5>
<p>主要用来 辅助开发者在不操作 DOM 的前提下 快速获取表单内的数据</p>
<p>v-model</p>
<pre><code class="lang-vue">&lt;div class=&quot;box&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            el: &#39;.box&#39;,
            data:{
                username: &#39;zhangsan&#39;
            }
        })
    &lt;/script&gt;
</code></pre>
<p>v-mode 专用的修饰符</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.number</td>
<td>自动将用户输入的值转为数值类型</td>
<td><input v-model.number="age"/></td>
</tr>
<tr>
<td>.trim</td>
<td>自动过滤用户输入的首尾空白字符</td>
<td><input v-model.trim="msg"/></td>
</tr>
<tr>
<td>.lazy</td>
<td>在 “change” 时而非 “input” 时更新</td>
<td><input v-model.lazy="msg"/></td>
</tr>
</tbody>
</table>
<h4 id="-">条件渲染指令</h4>
<p>条件渲染指令主要用来辅助开发者 按需控制 DOM 的显示与隐藏 ，条件渲染指令有如下两个</p>
<p>v-if</p>
<p>v-if 如果条件不成立 则它会在页面上动态的删除元素，如果条件成立 则动态生成元素</p>
<p>v-show</p>
<p>v-show 条件成立 它的属性就会变为 display : block, 如果条件不成立 则它的 display 属性会变为 none</p>
<p>在需要频繁切换元素的显示与隐藏 的时候 v-show 性能会更好 </p>
<p>v-for</p>
<p>v-for 提供了列表渲染指令 用来辅助开发者 基于一个数组循环渲染一个列表结构 v-for 指令需要使用 item in inems 形式的特殊语法 其中：</p>
<ul>
<li><p>items是待循环的数组</p>
</li>
<li><p>item　是被循环的每一项</p>
<pre><code class="lang-vue"> &lt;div id=&quot;app&quot;&gt;
        &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt;
            &lt;thead&gt;
                &lt;th&gt;id&lt;/th&gt;
                &lt;th&gt;性别&lt;/th&gt;
                &lt;th&gt;姓名&lt;/th&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;!-- 官方推荐 在使用 v-for 最好再声明一个 key 属性 而且最好把 id 作为 key 的值--&gt;
                &lt;!-- 官方对key 的值做了要求 只能是 字符串 或 数字 --&gt;
                &lt;!-- key 的值不能重复 否则终端会报错 Duplicate keys detectec --&gt;
                &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; :title=&quot;item.name&quot;&gt;
                    &lt;td&gt;{{index}}&lt;/td&gt;
                    &lt;td&gt;{{item.age}}&lt;/td&gt;
                    &lt;td&gt;{{item.name}}&lt;/td&gt;
                &lt;/tr&gt;

            &lt;/tbody&gt;
        &lt;/table&gt;

    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            // el 属性固定的写法 表示当前实例要控制页面上的那个区域 接收的值是一个选择器
            el: &#39;#app&#39;,
            // data 对象就是要填充的数据
            data:{
                username: &#39;zhangsan&#39;,
                list: [{
                    id: 1,
                    age: 18,
                    name: &#39;张三&#39;
                },{
                    id: 2,
                    age: 18,
                    name: &#39;李四&#39;
                },{
                    id: 3,
                    age: 18,
                    name: &#39;王五&#39;
                }]
            }
        })
    &lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="-">向列表内添加元素</h5>
<p>push </p>
<pre><code class="lang-vue">// 新建一个对象
const obj = {
                                id: this.nextId,
                                name: this.branch,
                                check: true,
                                time: new Date(),
                                remove: &#39;删除&#39;
                            }
                            // var name = this.branch;
                            // console.log(this.brandlist);
                            // 将新建的对象添加到 列表内
                            this.brandlist.push(obj);
</code></pre>
<h4 id="-">过滤器</h4>
<p>过滤器再　Vue 3 被取消了  只能再 Vue２　中使用</p>
<p>过滤器的使用 |  &quot; 管道符&quot;</p>
<p>过滤器要定义在 filters 的节点下面 与 data 是平级关系</p>
<p>管道符函数的前面那个数可以通过变量的形式获取 </p>
<p>必选要有返回值</p>
<p>全局过滤器</p>
<p>定义全局过滤器的方法</p>
<pre><code class="lang-javascript">// Vue.filter() 接收两个参数
// 第一个参数 全局过滤器的名字
// 第二个过滤器 是全局过滤器的 处理函数
Vue.filter(&#39;capitalize&#39;,function(val){
            const first = val.charAt(0).toUpperCase(0)
            const other = val.slice(1)
            return first + other
        })
</code></pre>
<p>如果全局过滤器与私有过滤器名称冲突了 调用的是私有的过滤器 就近原则</p>
<h4 id="-">侦听器</h4>
<p>监听数据变化做一件事</p>
<p>监视数据的变化 针对数据的变化做出特点的操作</p>
<pre><code class="lang-vue">//侦听器函数必须放到 watch对象中
&lt;div class=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            el: &#39;.app&#39;,
            data: {
                username: &#39;张三&#39;,
            },
            medhods:{},
            watch:{
                username(newVal,oldVal){
                    // 监听到了数据的变化就会触发 函数
                    console.log(newVal,oldVal)
                }
            }
        })
    &lt;/script&gt;
</code></pre>
<h5 id="-">侦听器的格式</h5>
<ol>
<li>方法格式的监听器<ul>
<li>缺点1： 无法在进入页面的时候自动触发</li>
<li>缺点2：如果侦听的是一个对象 如果对象内的属性发生了变化 不会触发侦听器</li>
</ul>
</li>
<li>对象格式的侦听器<ul>
<li>好处：可以通过 immediate 选项让侦听器自动触发</li>
<li>好处2：可以通过 deep 选项让侦听器深度侦听对象中的每个属性的变化</li>
</ul>
</li>
</ol>
<pre><code class="lang-vue">// 对象格式侦听器
&lt;div class=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;输入用户名&quot; v-model.trim.lazy=&quot;username&quot;&gt;
        &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; --&gt;
    &lt;/div&gt;
    &lt;script&gt;
        const vm = new Vue({
            el: &#39;.app&#39;,
            data:{
                username: &quot;admin&quot;,
            },
            watch:{
                username:{
                    handler(newVal,oldVal){
                        // console.log(newVal,oldVal)
                        axios({
                            method: &#39;get&#39;,
                            url: &quot;https://www.escook.cn/api/finduser/&quot; + newVal
                        }).then(function(res){
                            // console.log(res)
                            if(res.status === 200){
                                console.log(&#39;用户名可用&#39;)
                            }else{
                                console.log(&#39;用户名不可用&#39;)
                            }
                        })
                    },
                    immediate: true,
                }
            },
        })
    &lt;/script&gt;
</code></pre>
<h5 id="-">深度侦听器</h5>
<pre><code class="lang-vue">watch:{
                // 如果要侦听的是对象的子属性 则必须包裹一层双引号
                &quot;info.username&quot;(newVal){
                    console.log(newVal)
                },
                immediate: true,
            }
</code></pre>
<h4 id="-">计算属性</h4>
<p>特点</p>
<ul>
<li>定义的时候 要被定义为方法</li>
<li>在使用计算属性的时候 当普通的属性使用即可</li>
</ul>
<p>好处</p>
<ul>
<li>实现了代码的复用</li>
<li>只要计算属性中依赖的数据发生变化了，则会计算属性会自动重新求值</li>
</ul>
<pre><code class="lang-JavaScript"> computed:{
                // 动态生成 rgb 的函数
                rgb(){
                    return `rgb(${this.R},${this.G},${this.B})`
                }
            }
</code></pre>
<h4 id="axios-">axios 的使用</h4>
<pre><code class="lang-javascript">const vm1 = new Vue({
            el: &#39;.app1&#39;,
            methods:{
                    async btn (){
                        // 获取 data的属性
                    const {data} =  await axios({
                        method: &#39;post&#39;,
                        url: &#39;http://www.liulongbin.top:3006/api/addbook&#39;,
                        data:{
                            bookname: &#39;三国演义&#39;
                        }
                    })
                    // 将data 的属性打印出来
                    console.log(data)
                },

            }
        })
</code></pre>
<h5 id="async-await">async 和 await</h5>
<p>axios 直接发起get 请求</p>
<pre><code class="lang-javascript">get.addEventListener(&#39;click&#39;,async function(){
            const {data: res} = await axios.get(&#39;http://www.liulongbin.top:3006/api/getbooks&#39;,{
                params:{id:4}
            })
            console.log(res.data)
        })
</code></pre>
<p>axios 直接发起 post 请求</p>
<pre><code class="lang-javascript">post.addEventListener(&#39;click&#39;,async function(){
            const {data:res} = await axios.post(&#39;http://www.liulongbin.top:3006/api/getbooks&#39;)
        })
</code></pre>
<h4 id="-">单页面应用程序</h4>
<p>简称 SPA 指的是 Web 网站中只要唯一一个 html 页面 所有功能都在唯一一个页面内完成</p>
<h5 id="vue-cli">vue-cli</h5>
<p>vue-cli 是标准的 Vue.js 的开发工具 简化了程序员 基于 webpack 创建工程化 Vue 的过程</p>
<p>官网   <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<pre><code>全局安装 vue-cli
npm install -g @vue/cli
</code></pre><h5 id="vue-cli-">vue-cli 创建项目</h5>
<pre><code class="lang-bash">vue create 项目名称
</code></pre>
<h5 id="vue-src-">vue 中 src 目录中的结构</h5>
<pre><code>assets 文件夹 存放项目中的静态文件 例如 css 样式表 图片资源
companies 文件夹 程序员封装的可复用的组件 都要放到 companies 目录下
main.js 是项目的路口文件整个项目的运行要先执行 main.js
</code></pre><h5 id="vue-">vue 项目的运行流程</h5>
<p>在工程化项目中 vue 要做的事情很简单 通过 main.js 把 App.vue 渲染到 index.html 指定的区域中</p>
<p>其中</p>
<ul>
<li>App.vue 用来编写待渲染的模板结构</li>
<li>index.html 中需要预留一个 el 区域</li>
<li>main.js 把 App.vue 渲染到 index.html 所预留的区域中</li>
</ul>
<h5 id="vue-">vue 组件</h5>
<p>vue 的三个组成部分</p>
<ul>
<li>templare  组件的模板结构</li>
<li>script   组件 的 JavaScript 行为</li>
<li>style  组件的样式</li>
</ul>
<h5 id="-vue-">使用 vue 组件</h5>
<ul>
<li>使用 import 语法导入需要的组件</li>
<li>使用 components 节点注册组件</li>
<li>以标签的形式使用刚才注册的组件</li>
</ul>
<h4 id="-">注册全局组件</h4>
<p>在 vue 项目下的main.js 文件下 通过 Vue.component() 方法 可以注册全局组件</p>
<pre><code class="lang-Vue">import Cont from &quot;@/component/Count.vue&quot;

Vue.comonent(&#39;MyCount&#39;,Count)
</code></pre>
<h5 id="-props">自定义属性props</h5>
<p>props 是自定义属性 允许使用者自定义属性 为当前组件定义初始值</p>
<p>props 的值是只读的 不能修改</p>
<h5 id="-props-">定义 props 的默认值</h5>
<pre><code class="lang-vue">export default {
    props:{
        init :{
            default: 0;
        }
    }
}
</code></pre>
<h5 id="required-">required 的使用</h5>
<pre><code class="lang-vue">init: {
      default: 0,
      // 使用type 定义属性 定义 init 的值必须为数组
      type: Number,
      // init 的值必须填 不填将会强制报错
      required: true,
    },
</code></pre>
<h5 id="-">样式冲突问题的解决方法</h5>
<p>在style 的标签内添加一个 scoped 属性</p>
<p>表示在当前的页面元素自动添加一个 属性</p>
<h5 id="-">修改子组件的样式</h5>
<p>只有在 less 语言 时可以使用</p>
<p>/deep/ 标签 {}</p>
<p>在使用第三方库的时候修改样式可以用到</p>
<h4 id="-">组件的生命周期</h4>
<p>生命周期是指 一个组件从创建  &gt; 运行 &gt; 销毁 的整个阶段 强调的是一个时间段</p>
<h5 id="created-">created 生命周期</h5>
<pre><code class="lang-javascript"> // created 生命周期 函数非常常用
    // 经常在这生命周期里面 调用 methods 中的方法 请求服务器的数据
    created(){
        // console.log(this.info)
        // console.log(this.message)
        // console.log(this.show)
        console.log(this.initBooklist())
    },
</code></pre>
<h4 id="vue-">vue 的生命周期</h4>
<pre><code class="lang-javascript">&lt;script&gt;
export default {
    props:{
        info:{
            type: String,
        }
    },
    data(){
        return{
            message: &#39;hello Vue&#39;,
            books: &#39;&#39;,
            flag: true,
        }
    },
    methods:{
        show(){
            console.log(&#39;创建了 Show&#39;)
        },
        initBooklist(){
            const xml = new XMLHttpRequest()
            xml.addEventListener(&#39;load&#39;,() =&gt;{
                const result = JSON.parse(xml.responseText)
                console.log(result.data.length)
                this.books = result.data.length
            }),
            xml.open(&#39;get&#39;,&#39;http://www.liulongbin.top:3006/api/getbooks&#39;)
            xml.send()

        }
    },
    // 创建生命周期函数
    beforeCreate(){
        // console.log(this.info)
        console.log(this.message)
    },
    // created 生命周期 函数非常常用
    // 经常在这生命周期里面 调用 methods 中的方法 请求服务器的数据
    // 在这期间 props data methods 都是 可用的
    created(){
        // console.log(this.info)
        // console.log(this.message)
        // console.log(this.show)
        console.log(this.initBooklist())
    },
    // 第一次渲染 DOM 结构
    mounted(){
        console.log(this.$el)

    },
    // 将要根据变化过后 最新的数据重新渲染 组件的模板结构
    beforeUpdate(){
        // console.log(this.message)
    },
    // 当数据变化之后 为了操作最新的 DOM　结构　必须把代码写到　updted 元素里面
    updated(){
        console.log(this.message)
    },
    //  将要销毁的组件 此时尚未销毁 组价还处于 正常工作状态 
    // 销毁当前的 侦听器 子组件 时间监听
    beforeDestroy(){
        console.log(this.message)
    },
    // 当前组件已经完全被销毁 此组件的 DOM 结构在浏览器中完全被移除
    destroyed(){
        console.log(&#39;11&#39;)
    }
}
&lt;/script&gt;
</code></pre>
<h5 id="-">子组件向父组件传递数据</h5>
<p>子组件向父组件传递数据 需要使用 自定义数据 </p>
<pre><code class="lang-javascript">// 子组件的自定义事件
methods:{
        addcount(){
            this.count ++
            // 修改数据 通过创建自定义事件 $emit()
            this.$emit(&#39;addcount&#39;, this.count)
        }
    }
// 父组件的自定义 事件
methods:{
    getcount(val){
      this.countFromSon = val
    }
  }
// 父组件的标签
&lt;MyRight @addcount=&quot;getcount&quot;&gt;&lt;/MyRight&gt;
</code></pre>
<h5 id="-">兄弟组件相互传输数据</h5>
<p>兄弟组件之间数据共享方案是 EventBus</p>
<p>EventBus 的使用</p>
<ol>
<li>创建 eventBus.js 模块 并向外共享一个 Vue 的实例对象</li>
<li>在数据发送方 调用bus.$emit(&quot;事件名称&quot;,要发送的数据) 方法触发 自定义事件</li>
<li>在数据接收方，调用bus.$on(&quot;事件名称&quot;, 事件处理函数) 方法注册一个自定义事件</li>
</ol>
<pre><code class="lang-javascript">// 兄弟组件 数据发送方
data(){
    return{
        meg: &#39;hello&#39;
    }
}
// 兄弟组件 数据接收方
data(){
    return{
        msgFromLeft: &quot;&quot;
    }
}
</code></pre>
<h4 id="ref-">ref 的引用</h4>
<p>ref 用来 辅助开发者 在不依赖 jQuery的情况下 获取 DOM 元素组件的引用</p>
<h5 id="ref-">ref的使用</h5>
<pre><code class="lang-javascript">methods:{
    print(){
      // 在要操作的 DOM 元素标签内 定义一个 ref 的属性 
      // 在需要用到这个属性的时候 使用 this.$refs. 自定义属性 + 样式
      this.$refs.myh1.style.color = &#39;red&#39;
    }
  }
</code></pre>
<h5 id="-nexttick-function-">$nextTick(function)  方法</h5>
<p>等组件的 DOM 元素全部加载完成在执行的函数，从而保障 回调函数内的方法可以操作到最新的 DOM 元素</p>
<p>要延迟到最后执行的 事件 可以通过 this.$nextTick() 方法 </p>
<h4 id="-">动态组件</h4>
<h5 id="keep-alive-">keep-alive 保持状态</h5>
<p>防止组件被隐藏的时候销毁</p>
<p>使用方法：</p>
<pre><code class="lang-javascript">// 将要保持的组件包含到 keep-alive 标签内  
&lt;keep-alive&gt;
        &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
      &lt;/keep-alive&gt;
</code></pre>
<p>组件被缓存时会触发 deactivated 生命周期函数</p>
<p>组件被激活时会触发组件的 activated 生命周期函数</p>
<p>使用生命周期函数 要在子组件中使用 而不是在父组件中使用</p>
<h5 id="keep-alive-include-">keep-alive 的include 属性</h5>
<p>可以指定哪些组件被缓存 哪些组件被销毁</p>
<p>使用方法</p>
<pre><code class="lang-vue">// 在 include 中 的组会被缓存 不在 include 内的组件会被销毁 不同的组件中 用逗号隔开
&lt;keep-alive include=&quot;Left&quot;&gt;
        &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
      &lt;/keep-alive&gt;
</code></pre>
<h5 id="keep-alive-exclude-">keep-alive 的 exclude 属性</h5>
<p>include 属性是包含 exclude 属性是排除</p>
<p>哪个组件不想被 缓存 将组件名称 添加到 exclude 内</p>
<h4 id="-">插槽</h4>
<p>什么是插槽：</p>
<p>插槽是 Vue 为组件的封装者提供的能力 允许开发者在组装组件时 把不确定的希望用户指定的部分定义为插槽</p>
<p>v-solt 的简写是 #</p>
<h4 id="-">自定义指令</h4>
<h5 id="directives">directives</h5>
<p>在每个 vue 组件中 可以在 directives 节点下声明自定义指令 </p>
<h5 id="-">私有自定义指令</h5>
<pre><code class="lang-vue">&lt;h1 v-color=&quot;color&quot;&gt;App组件&lt;/h1&gt;
directives:{
  // 第定义一个 名为 color 的指令 指向一个配置对象
  // 当指令第一次被绑定到 元素上的时候 会立即触发 bind 函数
  color:{
    bind(el,binding){
      el.style.color =  binding.value
      console.log(el)

    },
    // 每次 DOM 更新的时候被调用
    update(el, binding){
      el.style.color = binding.value
    },
  },
},
</code></pre>
<h5 id="-">全局自定义指令</h5>
<p> 需要在 main.js 组件下定义</p>
<pre><code class="lang-javascript">// 定义一个全局自定义指令
Vue.directive(&#39;color&#39;, function(el, binding){
  el.style.color = binding.value
})
// 使用全局指令
&lt;p v-color=&quot;&#39;red&#39;&quot;&gt;使用全局自定义指令&lt;/p&gt;
</code></pre>
<h4 id="axios-">axios 的全局配置</h4>
<pre><code class="lang-javascript">import axios from &#39;axios&#39;

Vue.config.productionTip = false
// 在全局配置下导入 axios
Vue.prototype.$http = axios
// 在组件中发起请求不在需要导入 axios 模块 直接 this.$http 发起请求即可

// 全局配置 axios 请求的根路径 如果路径前面相同则可以直接省略
axios.defaults.baseURL = &#39;http://www.liulongbin.top:3006&#39;
</code></pre>
<h3 id="-">前端路由的概念与原理</h3>
<h4 id="-">什么是路由</h4>
<p>路由（英文：router）就是对应关系</p>
<p>Hash 地址 与 组件之间的对应关系</p>
<h4 id="-">前端路由的工作方式</h4>
<ol>
<li>用户点击了页面上的路由链接</li>
<li>导致了 URL 地址栏中的 Hash 值发生了变化</li>
<li>前端路由监听到了 Hash 地址的变化</li>
<li>前端路由把当前的 Hash 地址对应的组件渲染到浏览器中</li>
</ol>
<h4 id="-">前端路由的对应关系</h4>
<p>{ path: &#39;#/home&#39; , component: &#39;home&#39;}</p>
<h4 id="onhashchange">onhashchange</h4>
<p>当 hash 地址变化时 会触发该事件</p>
<h4 id="vue-router-">vue-router 的基本使用</h4>
<ol>
<li>安装 vue-router 包  （npm i npm-router -S）</li>
<li>创建 路由模块</li>
<li>导入并挂载路由模块</li>
<li>声明路由链接和占位符</li>
</ol>
<h5 id="-">创建路由模块</h5>
<p>在src 源代码目录下新建一个 router 文件夹</p>
<p>在文件下面新建一个 index.js 的 router 模块的文件</p>
<pre><code class="lang-JavaScript">// 导入Vue
import Vue from &#39;vue&#39;
// 导入 vue-router 包
import VueRouter from &quot;vue-router&quot;

// 调用 vue.use() 函数 把 VueRouter 安装为 Vue 插件
Vue.use(VueRouter)

// 创建路由的实例对象
const router = new VueRouter()

// 将创建好的路由实例对象向外共享
export default router
</code></pre>
<h5 id="-router-view">路由模块中的 router-view</h5>
<pre><code class="lang-JavaScript">// 导入需要的组件
import Home from &quot;@/components/myHome.vue&quot;
import Move from &quot;@/components/myMove.vue&quot;
import About from &quot;@/components/myAbout.vue&quot;

// 调用 vue.use() 函数 把 VueRouter 安装为 Vue 插件
Vue.use(VueRouter)

// 创建路由的实例对象
const router = new VueRouter({
  // routes 是一个数组 用来定义 hash 与 组件之间的对应关系
  routes: [
    {path:&#39;/home&#39;, component: Home},
    {path:&#39;/move&#39;, component: Move},
    {path:&#39;/about&#39;, component: About}
  ]
})

// 在需要使用组件的地方插入 
&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
<h5 id="-router-link">路由模块中的 router-link</h5>
<pre><code class="lang-html">&lt;!-- 在配置了 vue-router 之后 就可以使用 router-link 组件 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
    &lt;router-link to=&quot;/move&quot;&gt;电影页&lt;/router-link&gt;
    &lt;router-link to=&quot;/about&quot;&gt;详情页&lt;/router-link&gt;
    &lt;!-- &lt;a href=&quot;#/home&quot;&gt;首页&lt;/a&gt;
    &lt;a href=&quot;#/move&quot;&gt;电影页&lt;/a&gt;
    &lt;a href=&quot;#/about&quot;&gt;详细页&lt;/a&gt; --&gt;
</code></pre>
<h5 id="-">路由从定向</h5>
<pre><code class="lang-javascript">// 路由从定向 用户访问的 hash地址为 / 时，默认访问, home组件
    {path: &#39;/&#39;, redirect: &quot;/home&quot;},
</code></pre>
<h5 id="-">路由的嵌套</h5>
<pre><code class="lang-javascript">// 在子组件中的路由要写在父组件的路由规则下面
{
      path: &#39;/about&#39;,
      component: About,
      // 路由嵌套的重定向 指定地址跳转到新的地址
      redirect: &#39;/about/tab1&#39;,
      // 路由的嵌套 子路由下的模块切换
      children: [
        { path: &#39;tab1&#39;, component: Tab1 },
        { path: &#39;tab2&#39;, component: Tab2 },
      ]
    },
</code></pre>
<h5 id="-">动态路由</h5>
<pre><code class="lang-javascript">// :id 为占位符 
{ path: &#39;/move/:id&#39;, component: Move, props: true},
</code></pre>
<p>获取当前动态路由的 id </p>
<p>this.$route.params.id </p>
<p>在 this.$route 中 pash 只是路径部分 不包含查询部分</p>
<p>this.$route.fullpash 中包含了 整个路径</p>
<h5 id="-">路由导航</h5>
<p>在浏览器中，点击实现导航的方式，叫做声明式导航</p>
<ul>
<li>普通网页中点击 <a></a>链接， vue项目中点击 <router-link></router-link> 都属于 声明式导航</li>
</ul>
<p>在浏览器中，调用API方法实现导航的方式，叫做编程式导航</p>
<ul>
<li>普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航</li>
</ul>
<h4 id="vue-router-api">vue-router 中常见的编程式导航 API</h4>
<ul>
<li>this.$router.push(&quot; hash地址 &quot;) // 会增加一条历史记录</li>
<li>this.$router.replace(&quot; hash 地址 &quot;)  // 不会增加历史记录</li>
<li>this.$router.go( 数值 n )  // -1 表示后退到之前的历史记录 1 表示前进一格历史记录</li>
</ul>
<h5 id="-">后退和前进的简化用法</h5>
<p>this.$router.back()  // 后退一位</p>
<p>this.$router.forward()  // 前进一位历史记录</p>
<h4 id="-">导航守卫</h4>
<pre><code class="lang-javascript">// 为 route 实例对象，声明一个全局前置守卫
// 只要发生了路由的跳转，就必然会触发 beforeEach 的回调函数
  router.beforeEach(function(to, from, next){
  // to 是将要访问的路由信息对象
  // from 是将要离开的路由信息对象
  // next 是一个函数，调用 next() 表示放行， 允许这次的路由导航
  next()
})
</code></pre>
<p>next 的三种调用方式</p>
<ul>
<li>当用户拥有后台访问权限时，直接放行 next()</li>
<li>当用户没有后台访问权限时，强制跳转到登录页面 ，next(&quot; /login &quot;)</li>
<li>当用户没有后台访问权限，不允许跳转到后台主页： next( false )</li>
</ul>
<h4 id="vuex-">Vuex的基本使用</h4>
<h5 id="-vuex-">使用Vuex的好处</h5>
<ol>
<li>能够在Vuex中集中管理共享数据，易于开发和后期的维护</li>
<li>能够高效的实现组件之间的数据共享，提高开发效率</li>
<li>存储在Vuex中的数据都是相应式的，能够实时保持数据与页面的同步</li>
</ol>
<h5 id="-vuex-">什么样的数据适合存储到Vuex中</h5>
<p>只有组件之间共享的数据，才有必要存储到Vuex中，对于组件中的私有数据存储在自身的data中即可</p>
<h5 id="-vuex-">使用Vuex中的数据</h5>
<ul>
<li>this.$store.state.要使用的数据名称</li>
<li>导入Vuex组件，{ mapState }，创建一个计算属性函数 computed，展开运算符 ...mapState([&#39;数据名称&#39;])</li>
</ul>
<p>Vuex中的action专门用来执行异步的代码</p>
<h4 id="-token">储存 token</h4>
<p>localStorage.setItem(&#39; token &#39;, &#39; Bearer xxx &#39;)</p>
<h3 id="vue-3">Vue 3</h3>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>